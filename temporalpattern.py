import re


class TemporalPattern():
    def __init__(
        self,
        antecedent: 'List[Tuple[int,int,int]]' = [],
        consequence: 'Tuple[int,int,int]' = None,
        time_lags: 'List[Tuple[float,float]]' = [],
        n_hops: int = None,
    ):
        """ Defines a temporal pattern over our TKG
        Args:
            antecedent (List[Tuple[int,int,int]]): Antecedent(s) for the pattern
                in the form of subject, relation, object ID triples
            consequence (Tuple[int,int,int]): Consequence for the pattern in the form
                of a subject, relation, object ID triple
            time_lags (List[Tuple[float,float]]): Time lags with which antecedents and 
                consequences can occur validly in the pattern. Must be an iterable of
                length equal to the antecedent. The i-th element of time_lags is a
                tuple of the form (minimum # of time windows since i-th antecedent,
                maximum # of time windows since i-th antecedent) for the i+1-th
                antecedent (or consequence if we have iterated over all antecedents)
        """
        self.antecedent = antecedent
        self.consequence = consequence
        self.time_lags = time_lags
        self.n_hops = n_hops

        # Regex pattern used to parametrize a pattern from a text label
        self.pat_time_lag = re.compile('t\d+=t\d+\+\((\d+),\s(\d+)\)')
    
    def __label__(self) -> str:
        """ Return a string label for the pattern like <ANTECEDENT> -> <CONSEQUENCE>
        """
        label = ''
        for idx in range(len(self.antecedent)):
            if idx > 0:
                label += ' & '
            label += f'({self.antecedent[idx][0]}, '
            label += f'{self.antecedent[idx][1]}, '
            label += f'{self.antecedent[idx][2]}, '
            label += f't{idx+1}{f"=t{idx}+"+str(self.time_lags[idx-1]) if idx > 0 else ""})'
        label += ' -> '
        label += f'({self.consequence[0]}, '
        label += f'{self.consequence[1]}, '
        label += f'{self.consequence[2]}, '
        label += f't{len(self.antecedent)+1}{f"=t{len(self.antecedent)}+"+str(self.time_lags[-1])})'
        return label
    
    def __triples__(self) -> 'List[Tuple[int,int,int]]':
        """ Return antecedent and consequence as list of triples (excluding time lag information)
        """
        return self.antecedent + [self.consequence]
    
    def __quadruples__(self) -> 'List[Tuple[int,int,int,Tuple[float,float]]]':
        """ Return antecedent and consequence as list of quadruples (including time lag information)
        """
        return [
            triple + (time_lag,) for triple, time_lag in zip(self.__triples__(), [()]+self.time_lags)
        ]
    
    def from_label(self, label: str):
        """ Parametrize a pattern from a string label (as generated by __label__ method)
        """
        antecedent, consequence = label.split('->')
        antecedent = antecedent.split('&')
        # Get time lag information
        time_lags = [
            (
                int(self.pat_time_lag.search(text).groups()[0]),
                int(self.pat_time_lag.search(text).groups()[1])
            )
            for text in antecedent+[consequence]
            if self.pat_time_lag.search(text)
        ]
        # Format antecedent and consequence
        antecedent = [
            eval('('+','.join(ant.strip(' ()').split(',')[:3])+')')
            for ant in antecedent
        ]
        consequence = eval('('+','.join(consequence.strip(' ()').split(',')[:3])+')')
        
        self.antecedent = antecedent
        self.consequence = consequence
        self.time_lags = time_lags
        self.n_hops = len(antecedent)
